# ReverseEngineeringProject
This is a security brief of an application that I disassembled &amp; reversed engineered back into a C source file.


## Code Functionality
The purpose of this code is to allow a user to login with a name and password to view and change the grades of an array of students. This program consists of four functions: main, ReadUserInfo, CheckUserPermissionAccess, and DisplayStudentInformation. The ReadUserInfo function is the first method called by the main function, it does not have any parameters. The purpose of this function is to prompt the user with a message asking them to enter their name and password. The CheckUserPermissionAcces function is the second function called by the main function. This function also does not take any parameters but returns a binary value. The purpose of this function is to compare the password entered by the user in the ReadUserInfo function to a predefined password set by the developers of the program. When comparing the password entered by the user to the preset password, if the values match the function returns a one, if they do not match the function returns a zero. The DisplayStudentInformation function is called twice in the main function. It first called to display an initial list of the students and their grades and the second time it is called is after the grades have been adjusted by the user. This function uses a loop to display the elements of the array, which includes the name and grade of each student.

## Disassembling Process
To disassemble this program, I used GNU debugger (GDB) to identify each function and disassemble them individually. The GDB commands that I used to disassemble this program were the “info” and “disassemble” commands in conjunction with each function name. In using these two commands I was able to view all of the functions for this program. In addition to other actions, gdb allows us to run the program while setting breakpoints to examine code. Using breakpoints offers an opportunity to step into each instruction were it can be seen where the variables are stored and the memory location. The gbd commands that support the examination of these steps while the program is running are si and ni. Also, p or x/s commands show the value in the memory location. To gather more information about the details of the program I used a hex editor to view a binary dump of the program. This dump revealed strings, string modifiers and the contents of some of the variables contained within the program.

## Expoloitable Weaknesses and Vulnerabilites
One of the weaknesses in this program is that the value that is used for comparing the password is exposed in the main function. Simply using a tool like the GNU debugger will reveal that the result of the CheckUserPermissionAccess compares the user input with the value one. An attacker could theoretically implement a buffer overflow attack to insert the value one into the location in memory and gain access to the program. A second vulnerability is that the program only verifies the user’s password but not the user’s name. This vulnerability is also easily revealed by the GNU Debugger. This vulnerability can’t really be exploited by the attacker, it just makes it easier for them to get in because they only need to worry about getting the password correct. 

## Basic Recommendations
This program should be modified with the vulnerabilities and weakness outlined in this report in mind. The first modification to this program should be to verify both the user’s password and their name in the CheckUserPermissionAccess function. The second modification should be to hide the value returned by the comparison in the CheckUserPermissionAccess  using a hashing algorithm. 
